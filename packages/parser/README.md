# @timus/parser

> NOTE: This is a work in progress.

## Introduction

The main purpose of Timus Parser is to analyze programming languages with the same syntactic characteristics as JavaScript, but with different words.

The parser is necessary so that we can build a compiler for those languages.

Consider the following code snippet, written in JavaScript:

```javascript
function factorial(n) {
    if (n === 0)
        return 1;
    return n * factorial(n - 1);
}
```

Now see the same piece of code written in Lume, the corresponding version of JavaScript that uses Portuguese words that we created.

```lume
funÃ§Ã£o fatorial(n) {
    se (n === 0)
        retornar 1;
    retornar n * fatorial(n - 1);
}
```

Note that the same JavaScript rules are valid, but with different keywords.

Also note that we have chosen to change the identifier "factorial" to "fatorial", which is how the word is written in Portuguese. However, the choice of identifier name is and will remain with the developer. We did this only to maintain consistency with language changes.

Other variations could be created, using terms in other languages - Spanish, for example - or at the discretion of those who are creating the "new" language:

```
fn fact(n) {
    if (n === 0)
        rtn 1;
    rtn n * fact(n - 1);
}
```

Remember that any UNICODE character can be used. See a short excerpt written in Happy, a language that uses emotions as synonyms for some words:

```happy
ðŸ˜´ fn lazy(value) {
  ðŸ¤” (value < 1)
    ðŸ‘‰ 10;
  ðŸ‘‰ 20;
}
```

The result generated by the parser is a tree data structure. In English, this structure is known as AST (abstract syntax tree). Below is a small snippet of the AST generated for the JavaScript code given as an example above:

```json
{
  "type": "Program",
  "start": 0,
  "end": 93,
  "body": [
    {
      "type": "FunctionDeclaration",
      "start": 0,
      "end": 93,
      "id": {
        "type": "Identifier",
        "start": 9,
        "end": 18,
        "name": "factorial"
      },
      "expression": false,
      "generator": false,
      "async": false,
      "params": [
        {
          "type": "Identifier",
          "start": 19,
          "end": 20,
          "name": "n"
        }
      ],
      "body": {
          ...
      }
    }
  ],
  "sourceType": "module"
}
```

The purpose of Timus Parser is to generate the same structure as a result for any of the language variations. The only differences are in the start and end fields of each node in the tree, because of the variations in the length of the words. This is important for the structure to be a real representation of the analyzed source code.